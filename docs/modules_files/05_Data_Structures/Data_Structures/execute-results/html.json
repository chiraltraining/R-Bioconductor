{
  "hash": "a6fbc769167fd4219cfc78cefa01cfe5",
  "result": {
    "markdown": "---\ntitle: \"Data Structures\"\nauthor: \"Jubayer Hossain\"\ninstitute: \"[Founder & Instructor, CHIRAL Bangladesh](https://chiralbd.org/)\"\ndate: \"11 March 2023\"\noutput:\n  html_document:\n    toc: true\n    #number_sections: true\n    toc_depth: 6\n    toc_float: true \n    theme: flatly\n---\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'readr' was built under R version 4.2.2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'forcats' was built under R version 4.2.2\n```\n:::\n:::\n\n\n\n# One dimensional types (\"vectors\")\n\n## Data Types\n\n    * Character: strings or individual characters, quoted\n    * Numeric: any real number(s)\n    * Integer: any integer(s)/whole numbers\n    * Factor: categorical/qualitative variables\n    * Logical: variables composed of TRUE or FALSE\n    * Date/POSIXct: represents calendar dates and times\n\n## Character and numeric\n\nWe have already covered `character` and `numeric` types.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(\"tree\", \"cloud\", \"stars_&_sky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n## Character and numeric\n\nThis can also be a bit tricky.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(1, 2, \"tree\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(\"1\", \"4\", \"7\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n## Numeric Subclasses\n\nThere are two major numeric subclasses\n\n1) Integer\n2) Double\n\n\n## Integer{.small}\n\n`Integer` is a special subset of `numeric` that contains only <span style=\"color: red;\">whole numbers</span>.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n## Double\n\n`Double` is a special subset of `numeric` that contains <span style=\"color: red;\">fractional values</span>.\n\n`Double` stands for [double-precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1.1, 2.0, 3.2, 4.5, 5.6)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.1 2.0 3.2 4.5 5.6\n```\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\n\n## Checking double vs integer\n\nA `tibble` will show the difference (as does `glimpse()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(xvar = x, yvar = y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n   xvar  yvar\n  <dbl> <dbl>\n1     1   1.1\n2     2   2  \n3     3   3.2\n4     4   4.5\n5     5   5.6\n```\n:::\n:::\n\n\n## Logical\n\n`logical` is a type that only has two possible elements: `TRUE` and `FALSE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE, TRUE, TRUE, FALSE)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\nNote that `logical` elements are NOT in quotes. \n\n::: {.cell}\n\n```{.r .cell-code}\nz <- c(\"TRUE\", \"FALSE\", \"TRUE\", \"FALSE\")\nclass(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n\n## General Class Information\n\nThere are two useful functions associated with practically all R classes: \n\n- `is.CLASS_NAME(x)` to **logically check** whether or not `x` is of certain  class \n- `as.CLASS_NAME(x)` to **coerce between classes** `x` from current `x` class into a certain class \n\n\n\n## General Class Information: Checking\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.character(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.character(c(\"tree\", \"cloud\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(c(\"tree\", \"cloud\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\n\n## General Class Information: coercing\n\nIn some cases the coercing is seamless: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"4\" \"7\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"FALSE\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nas.integer(c(1.2, 3.7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\nas.double(c(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n## General Class Information: coercing\n\nIn some cases the coercing is not possible; if executed, will return `NA` (an R constant representing \"**N**ot **A**vailable\" i.e. missing value)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7a\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4 NA\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"UNKNOWN\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE    NA\n```\n:::\n\n```{.r .cell-code}\nas.Date(c(\"2021-06-15\", \"2021-06-32\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-15\" NA          \n```\n:::\n:::\n\n\n\n## Factors\n\nA `factor` is a special `character` vector where the elements have pre-defined groups or 'levels'. You can think of these as qualitative or categorical variables. Use the `factor()` function to create factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"small\", \"mediam\", \"large\", \"medium\", \"large\")\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nx_fact <- factor(x) # factor() is a function\nclass(x_fact)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nx_fact\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] small  mediam large  medium large \nLevels: large mediam medium small\n```\n:::\n:::\n\n\nNote that levels are, by default, in **alphanumerical** order!\n\n## Factors\n\nYou can learn what are the unique levels of a `factor` vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(x_fact)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"large\"  \"mediam\" \"medium\" \"small\" \n```\n:::\n:::\n\n\nMore on how to change the levels ordering in a lecture coming up! \n\n\n## Factors\n\nFactors can be converted to `numeric` or `character` very easily.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_fact\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] small  mediam large  medium large \nLevels: large mediam medium small\n```\n:::\n\n```{.r .cell-code}\nas.character(x_fact)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\"  \"mediam\" \"large\"  \"medium\" \"large\" \n```\n:::\n\n```{.r .cell-code}\nas.numeric(x_fact)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2 1 3 1\n```\n:::\n:::\n\n\n\n## Useful functions to create vectors `rep()`\n\nFor character: `rep()` can create very long vectors. \nWorks for creating character and numeric vectors.\n\nThe `each` argument specifies how many of each item you want repeated.\nThe `times` argument specifies how many times you want the vector repeated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"black\", \"white\"), each = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"black\" \"black\" \"black\" \"white\" \"white\" \"white\"\n```\n:::\n\n```{.r .cell-code}\nrep(c(\"black\", \"white\"), times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"black\" \"white\" \"black\" \"white\" \"black\" \"white\"\n```\n:::\n\n```{.r .cell-code}\nrep(c(\"black\", \"white\"), each = 2, times = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"black\" \"black\" \"white\" \"white\" \"black\" \"black\" \"white\" \"white\"\n```\n:::\n:::\n\n\n## Useful functions to create vectors `seq()`\n\nFor numeric: `seq()` can be very useful- both integer and double.   \nThe `from` argument says what number to start on.    \nThe `to` argument says what number to not go above.   \nThe `by` argument says how much to increment by.    \nThe `length.out` argument says how long the vector should be overall.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 0, to = 1, by = 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0 0.2 0.4 0.6 0.8 1.0\n```\n:::\n\n```{.r .cell-code}\nseq(from = 0, to = 10, by = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nseq(from = -5, to = 5, length.out = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -5.0000000 -3.8888889 -2.7777778 -1.6666667 -0.5555556  0.5555556\n [7]  1.6666667  2.7777778  3.8888889  5.0000000\n```\n:::\n:::\n\n\n## Creating numeric vectors `sample()`\n\n You can use the `sample()` function to make a random sequence.\n The `x` argument specifies what you are sampling from.\n The `size` argument specifies how many values there should be.\n The `replace` argument specifies if values should be replaced or not.\n \n\n::: {.cell}\n\n```{.r .cell-code}\nseq_hun <- seq(from = 0, to = 100, by = 1)\nseq_hun\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17\n [19]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35\n [37]  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53\n [55]  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71\n [73]  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89\n [91]  90  91  92  93  94  95  96  97  98  99 100\n```\n:::\n\n```{.r .cell-code}\ny <- sample(x = seq_hun, size = 5, replace = TRUE)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6 43 43 16 56\n```\n:::\n:::\n\n## Summary\n\n- There are two types of numeric class objects: integer and double\n- Logic class objects only have `TRUE` or `False` (without quotes)\n- is.CLASS_NAME(x) can be used to test the class of an object x\n- as.CLASS_NAME(x) can be used to change the class of an object x\n- Factors are a special character class that has levels - more on that soon!\n- The repeat `rep()` function helps you create vectors with the `to` and `from` arguments\n- The sequence `seq()` function helps you create numeric vectors (`from`,`to`, `by`, and `length.out` arguments)\n- `seq()` can be used for integers or double numeric vectors (`by` argument)\n- `sample()` makes random vectors. Can be used for integers or double depending on what it is sampling from.\n- tibbles show column classes!\n\n## Lab Part 1\n\n🏠 [Class Website](https://jhudatascience.org/intro_to_r/)    \n💻 [Lab](https://jhudatascience.org/intro_to_r/modules//Data_Classes/lab/Data_Classes_Lab.Rmd)\n\n# Two-dimensional data classes\n\n## Two-dimensional data classes\n\nTwo-dimensional classes are those we would often use to store data read from a file \n\n* a data frame (`data.frame` or `tibble` class)\n\n* a matrix (`matrix` class)\n\n    * also composed of rows and columns\n    * unlike `data.frame` or `tibble`, the entire matrix is composed of one R class\n    * for example: all entries are `numeric`, or all entries are `character`\n\n\n## Matrices\n\n`as.matrix()` creates a matrix from a data frame (where all values are the same class).\n`matrix()` creates a matrix from scratch.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n\n```{.r .cell-code}\nclass(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\niris_mat <- head(tibble(select(iris, -Species)))\nas.matrix(iris_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Sepal.Length Sepal.Width Petal.Length Petal.Width\n[1,]          5.1         3.5          1.4         0.2\n[2,]          4.9         3.0          1.4         0.2\n[3,]          4.7         3.2          1.3         0.2\n[4,]          4.6         3.1          1.5         0.2\n[5,]          5.0         3.6          1.4         0.2\n[6,]          5.4         3.9          1.7         0.4\n```\n:::\n\n```{.r .cell-code}\nmatrix(1:6, ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n\n\n## Lists\n\n* One other data type that is the most generic are `lists\n* Can be created using `list()`\n* Can hold vectors, strings, matrices, models, list of other list!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(c(\"A\", \"b\", \"c\"), c(1, 2, 3), matrix(1:4, ncol = 2))\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"A\" \"b\" \"c\"\n\n[[2]]\n[1] 1 2 3\n\n[[3]]\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nclass(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\n## Lists\n\nList elements can be named\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist_named <- list(\n  letters = c(\"A\", \"b\", \"c\"),\n  numbers = c(1, 2, 3),\n  one_matrix = matrix(1:4, ncol = 2)\n)\nmylist_named\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$letters\n[1] \"A\" \"b\" \"c\"\n\n$numbers\n[1] 1 2 3\n\n$one_matrix\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n:::\n\n\n\n# Special data classes\n\n## Dates\n\nThere are two most popular R classes used when working with dates and times: \n\n- `Date` class representing a calendar date\n- `POSIXct` class representing a calendar date with hours, minutes, seconds\n\nWe convert data from character to `Date`/`POSIXct` to use functions to manipulate date/date and time\n\n`lubridate` is a powerful, widely used R package from \"tidyverse\" family to work with `Date` / `POSIXct` class objects \n\n## Creating `Date` class object  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(\"2021-06-15\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'lubridate' was built under R version 4.2.2\n```\n:::\n\n```{.r .cell-code}\nymd(\"2021-06-15\") # lubridate package\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-15\"\n```\n:::\n\n```{.r .cell-code}\nclass(ymd(\"2021-06-15\")) # lubridate package\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n\n```{.r .cell-code}\nclass(date(\"2021-06-15\")) # lubridate package\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n:::\n\n\nNote for  function `ymd`: **y**year **m**onth **d**ay  \n\n## dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- ymd(\"2021-06-15\")\nb <- ymd(\"2021-06-18\")\na - b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of -3 days\n```\n:::\n:::\n\n\n\n## Creating `Date` class object \nThis will not work:\n`date()` is picky...\n\n::: {.cell}\n\n```{.r .cell-code}\ndate(\"06/15/2021\")\n```\n:::\n\nThis works though!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy(\"06/15/2021\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-15\"\n```\n:::\n\n```{.r .cell-code}\nmdy(\"06/15/21\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-15\"\n```\n:::\n:::\n\n\nNote for  function `mdy`: **m**onth **d**ay  **y**year\n\n## Creating `POSIXct` class object  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(\"2013-01-24 19:39:07\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nymd_hms(\"2013-01-24 19:39:07\") # lubridate package\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2013-01-24 19:39:07 UTC\"\n```\n:::\n\n```{.r .cell-code}\nclass(ymd_hms(\"2013-01-24 19:39:07\")) # lubridate package\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n:::\n\n\nUTC represents time zone, by default: Coordinated Universal Time\n\nNote for  function `ymd_hms`: **y**year **m**onth **d**ay **h**our **m**inute **s**econd. \n\nThere are functions in case your data have only date, hour and minute (`ymd_hm()`) or only date and hour (`ymd_h()`). \n\n\n## Summary\n\n - two dimensional object classes include: data frames, tibbles, matrices, and lists\n - matrix has columns and rows but  is all one data class\n     - can create a matrix with `matrix()` from scratch or `as.matrix()` from something\n - lists can contain multiples of any other class of data including lists!\n     - can create lists with `list()`\n - calendar dates can be represented with the `Date` class using `ymd()`, `mdy()` functions from `lubridate` package \n- `POSIXct` class representing a calendar date with hours, minutes, seconds. Can use `ymd_hms()` or `ymd_hm()` or `ymd_h()`functions from the `lubridate` package\n\n## Lab Part 2\n\n🏠 [Class Website](https://jhudatascience.org/intro_to_r/)    \n💻 [Lab](https://jhudatascience.org/intro_to_r/modules//Data_Classes/lab/Data_Classes_Lab.Rmd)\n\n# Extra Slides\n\n\n## Some useful functions from `lubridate` to manipulate `Date` objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(c(\"2021-06-15\", \"2021-07-15\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-15\" \"2021-07-15\"\n```\n:::\n\n```{.r .cell-code}\nday(x) # see also: month(x) , year(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15 15\n```\n:::\n\n```{.r .cell-code}\nx + days(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-06-25\" \"2021-07-25\"\n```\n:::\n\n```{.r .cell-code}\nx + months(1) + days(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-07-25\" \"2021-08-25\"\n```\n:::\n\n```{.r .cell-code}\nwday(x, label = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Tue Thu\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n```\n:::\n:::\n\n\n## Some useful functions from `lubridate` to manipulate `POSIXct` objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(\"2013-01-24 19:39:07\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2013-01-24 19:39:07 UTC\"\n```\n:::\n\n```{.r .cell-code}\ndate(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2013-01-24\"\n```\n:::\n\n```{.r .cell-code}\nx + hours(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2013-01-24 22:39:07 UTC\"\n```\n:::\n\n```{.r .cell-code}\nfloor_date(x, \"1 hour\") # see also: ceiling_date()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2013-01-24 19:00:00 UTC\"\n```\n:::\n:::\n\n\n## Differences in dates \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- ymd(c(\"2021-06-15\"))\nx2 <- ymd(c(\"2021-07-15\"))\n\ndifftime(x2, x1, units = \"weeks\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 4.285714 weeks\n```\n:::\n\n```{.r .cell-code}\nas.numeric(difftime(x2, x1, units = \"weeks\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.285714\n```\n:::\n:::\n\n\nSimilar can be done with time (e.g. difference in hours). \n\n# Data Selection\n\n## Matrices\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1:9\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8 9\n```\n:::\n\n```{.r .cell-code}\nmat <- matrix(n, nrow = 3)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\n## Vectors: data selection\n\nTo get element(s) of a vector (one-dimensional object): \n\n- Type the name of the variable and open the rectangular brackets `[ ]`\n- In the rectangular brackets, type index (/vector of indexes) of element (/elements) you want to pull. **In R, indexes start from 1** (not: 0)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"\n```\n:::\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\"\n```\n:::\n\n```{.r .cell-code}\nx[c(1, 2, 100)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" NA \n```\n:::\n:::\n\n\n\n\n## Matrices: data selection\n\nNote you cannot use `dplyr` functions (like `select`) on matrices. To subset matrix rows and/or columns, use `matrix[row_index, column_index]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\nmat[1, 1] # individual entry: row 1, column 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmat[1, 2] # individual entry: row 1, column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmat[1, ] # first row\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\nmat[, 1] # first column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmat[c(1, 2), c(2, 3)] # subset of original matrix: two rows and two columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    4    7\n[2,]    5    8\n```\n:::\n:::\n\n\n\n## Lists: data selection\n\nYou can reference data from list using `$` (if elements are named) or using `[[ ]]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist_named[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nmylist_named[[\"letters\"]] # works only for a list with elements' names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nmylist_named$letters # works only for a list with elements' names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"b\" \"c\"\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}